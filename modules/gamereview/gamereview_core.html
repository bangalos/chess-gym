<!doctype html>
<html>
<head>
  <!--<meta name="viewport" content="width=600,user-scalable=no" />-->
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  
  <meta http-equiv="cache-control" content="max-age=0" />
  <meta http-equiv="cache-control" content="no-cache" />
  <meta http-equiv="expires" content="0" />
  <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
  <meta http-equiv="pragma" content="no-cache" />
  
  <title>Game Review Module</title>
  
</head>
<body>

  <!-- start example HTML --->
  <div>Memorable information: <span id="memorable"></span></div>
  <p>Enter your move on the board in <span id="countdown-holder">X</span> seconds</p>
  <div style="clear:both"></div>
  <div style="overflow:hidden">
      <div style="width:30%;display:block;float:left">&#160;</div>
      <div id="board" style="width:40%;margin:auto;float:left"></div>
      <div id="progressBar" style="display:none;margin-left:20px;float:left"><div></div></div>
  </div>
  <div class="footer" style="position:relative;margin-top:30px;">
      <div><a href="SECRETNEXT">Next Game</a></div>
      <p>Score: <span id="score"></span></p>
      <p>Status: <span id="status"></span></p>
      
      <div id="circle_black" style="display:none"></div>
      <div id="circle_white" style="display:none"></div>
        
      <p>FEN: <span id="fen"></span></p>
      <p>PGN: <span id="pgn"></span></p>
      <p>Mobility for pieces: <label id="mobilityStr"></label></p>
      <p>Total no. of spaces to move to in opponent's camp: <label id="opponentSpacesCnt"></label></p>

      <button onclick="flipTheBoard()">Flip Board</button>
      <button id="pauseBtn" onclick="pause()">Pause</button>
      
  </div>
  
  <svg id="arrow-svg" style="width:100%">
      
      <defs>
          <marker id="arrow" markerWidth="13" markerHeight="13" refx="2" refy="6" orient="auto">
              <path id="arrow-head-path" d="M-1,2 L-1,11 L6,6 z" style="fill:yellow;" />
          </marker>
      </defs>
      
      <path id="arrow-path" d="" style="stroke:yellow;stroke-width:2.25px;fill:none;marker-end: url(#arrow);"
      />
      
  </svg>

  <!-- end example HTML --->
  <script>
     function getUrlRoot() {
        return (window.location.hostname == 'localhost') ? '/drupal' : '';
     }

     function addStylesheet(href) {
        var s = document.createElement('link');
        s.setAttribute('rel', 'stylesheet');
        s.setAttribute('href', getUrlRoot() + href);
        document.head.appendChild(s);
     }

     function addScript(src) {
        var s = document.createElement('script');
        s.setAttribute('src', getUrlRoot() + src);
        document.head.appendChild(s);
     }

     addStylesheet("/sites/default/files/chessgym/css/chessboard.css");
     addStylesheet("/sites/default/files/chessgym/css/chessgym.css");
          
     addScript("/sites/default/files/chessgym/js/chess.js");
     addScript("/sites/default/files/chessgym/js/json3.min.js");
     addScript("/sites/default/files/chessgym/js/jquery-1.10.1.min.js");
     addScript("/sites/default/files/chessgym/js/chessboard.js");
     addScript("/sites/default/files/chessgym/js/countdown.js");

  </script>
  
  <script defer='defer'>
      // required for debugging
//            document.onmousemove = function(e){
//                var x = e.pageX;
//                var y = e.pageY;
//                console.log("X is "+x+" and Y is "+y);
//            };

    var INIT_TIMER = 15;
    var memorable_init = 'SECRETGENBG';
    var pgn_init = ['[Event "Chess Gym Game Review"]',
       '',
       'SECRETPGN'];

    var all_moves,moveThreshold, counter, board, game, scratch_game, fenEl, pgnEl, memEl, paused = 0, savedCall;
    var user_input_move = 'blank';
    var fifteenTimer = 1;
    var keymove_score = "Neutral";
    var your_score= 0;
    var total_moves = 0;
    var game_ended = 0;
    var plies_remaining = 0;

    var init = function() {
        game = new Chess();
        scratch_game = new Chess();
        statusEl = $('#status');
        fenEl = $('#fen');
        pgnEl = $('#pgn');
        memEl = $('#memorable');
        memEl.html(memorable_init);
        scoreEl = $('#score');
        
        
        
//        $('#cnvsdiv').detach();


      // do not pick up pieces if the game is over
      // only pick up pieces for the side to move

      var onDragStart = function(source, piece, position, orientation) {
        if (game.game_over() === true ||
           (game.turn() === 'w' && piece.search(/^b/) !== -1) ||
           (game.turn() === 'b' && piece.search(/^w/) !== -1)) {
          return false;
        }
      };

      var onDrop = function(source, target) {
        // see if the move is legal
        var move = game.move({
          from: source,
          to: target,
          promotion: 'q' // NOTE: always promote to a queen for example simplicity
        });
        
        // legal move
        if (move != null) {
          var throwaway_history = game.history();
          user_input_move = throwaway_history[throwaway_history.length-1];
          game.undo();
          if (counter >= moveThreshold) {
              drawArrow(source, target, 0);
              real_move_to = all_moves[counter]
              setTimeout("updateArrow('"+(real_move_to.endsWith(target))+"');", 1500);
          }
          
          return 'snapback';
        }
        // illegal move
        if (move === null) return 'snapback';
        updateStatus();
      };

      // update the board position after the piece snap 
      // for castling, en passant, pawn promotion
      var onSnapEnd = function() {
        board.position(game.fen());
      };

      var updateStatus = function() {
        var status = '';

        var moveColor = 'White';
        if (game.turn() === 'b') {
          moveColor = 'Black';
        }

        // checkmate?
        if (game.in_checkmate() === true) {
          status = 'Game over, ' + moveColor + ' is in checkmate.';
        }

        // draw?
        else if (game.in_draw() === true) {
          status = 'Game over, drawn position';
        }

        else if (game_ended == 1) {
          status = 'Game over';
        }

        // game still on
        else {
          status = moveColor + ' to move';

          // check?
          if (game.in_check() === true) {
            status += ', ' + moveColor + ' is in check';
          }
        }

        if (keymove_score == "Success") {
          your_score++;
          total_moves++;
          keymove_score = "Neutral";
        }
        if (keymove_score == "Fail") {
          total_moves++;
          keymove_score = "Neutral";
        }
        plies_remaining = all_moves.length - counter;
        score_html = "User move: " + user_input_move + "<br/>";
        score_html += "Game move: " + all_moves[counter-1] + "<br/>";
        score_html +=  "Plies remaining: " + plies_remaining + "<br/>Your Score: " + your_score + "/" + total_moves;

        statusEl.html(status);
        fenEl.html(game.fen());
        pgnEl.html(game.pgn());
        scoreEl.html(score_html);
        
        if (moveColor == "Black") {
            $('#circle_black').show();
            $('#circle_white').hide();
        } else {
            $('#circle_white').show();
            $('#circle_black').hide();
        }
        
//        var blackPossibleMoves = filterMovesForSide(game.moves({legal: true, verbose: true, turn: 'b'}), 'b'); // all black moves
//        var whitePossibleMoves = filterMovesForSide(game.moves({legal: true, verbose: true, turn: 'w'}), 'w'); // all white moves
//        var allPossibleMoves = []
//        allPossibleMoves.concat(blackPossibleMoves, whitePossibleMoves);
        var myPossibleMoves = filterMovesForSide(game.moves({legal: true, verbose: true}), game.turn());

        var mobility = getMobilityForPieces(myPossibleMoves);
        
        var mobilityStr = "";
        $(':not([data-square=""])').removeClass("highlight-mobility");
        for (var m = 0; m < mobility.length; m++) {
            var pieceMove = mobility[m]["move"];
            var aMobilityStr = pieceMove.piece + "/" + pieceMove.to + "=" + mobility[m]["cnt"];
            mobilityStr = mobilityStr + aMobilityStr + ";";
            $('*[data-square=' + pieceMove.from + ']').addClass("highlight-mobility");
        }
        
        $("#mobilityStr").html(mobilityStr);
        
        var movesByUniqueSpaces = filterMovesOnUniqueSpaces(myPossibleMoves);
        var opponentSpaces = filterMovesInOpponentCamp(movesByUniqueSpaces);
        $("#opponentSpacesCnt").html(opponentSpaces.length);
      };

      var cfg = {
        draggable: true,
        position: 'start',
        onDragStart: onDragStart,
        onDrop: onDrop,
        onSnapEnd: onSnapEnd
      };

      function highlightLastMove(move) {
          $(':not([data-square=""])').removeClass("highlight-last-move");
          $('*[data-square=' + move.from + ']').addClass("highlight-last-move");
          $('*[data-square=' + move.to + ']').addClass("highlight-last-move");
      }
      
      var makeMoveUntil = function () {
        if (!paused) {
            var moveInfo = game.move(all_moves[counter]);
            highlightLastMove(moveInfo);
            board.position(game.fen());
            counter++;
            if (counter < moveThreshold) {
                setTimeout(makeMoveUntil, 1000);
            } else {
                setTimeout(interactiveMove, 1000);
            }
            updateStatus();
        } else {
            savedCall = function (){makeMoveUntil()};
        }
      }

      var interactiveMove = function () {
        if (!paused) {
            var moveInfo = game.move(all_moves[counter]);
            highlightLastMove(moveInfo);
            board.position(game.fen());
            counter++;
            updateStatus();
            fifteenTimer = INIT_TIMER;
            keymove_score = "Neutral";
            $('#progressBar').show();
            progress(fifteenTimer);
            setTimeout(checkEverySecond, 1000);
            $("#countdown-holder").html(fifteenTimer);
            user_input_move = 'blank';
        } else {
            savedCall = function (){interactiveMove()};
        }
      }

      var checkEverySecond = function (){
        
        if (!paused) {
            fifteenTimer--;
            $("#countdown-holder").html(fifteenTimer);
            progress(fifteenTimer);
            if (user_input_move != 'blank') {
                if (user_input_move == all_moves[counter]) {
                    keymove_score = "Success";
                } else {
                    keymove_score = "Fail";
                }
                var moveInfo = game.move(all_moves[counter]);
                highlightLastMove(moveInfo);
                board.position(game.fen());
                counter++;
                updateStatus();
                if (counter+1 < all_moves.length) {
                    setTimeout(interactiveMove, 3000);
                } else {
                    game_ended = 1;
                }
            } else {
                if (fifteenTimer > 0) {
                    if (counter+1 >= all_moves.length) {
                        game_ended = 1;
                    }
                    setTimeout(checkEverySecond, 1000);
                } else {
                    var moveInfo = game.move(all_moves[counter]);
                    highlightLastMove(moveInfo);
                    board.position(game.fen());
                    counter++;
                    keymove_score = "Fail";
                    if (counter+1 >= all_moves.length) {
                        game_ended = 1;
                    }
                    updateStatus();
                    if (counter+2 < all_moves.length) {
                        setTimeout(interactiveMove, 3000);
                    }
                }
            }
         } else {
                savedCall = function (){checkEverySecond()};
        }

      }
      board = ChessBoard('board', cfg);
      scratch_game.load_pgn(pgn_init.join('\n'));
      all_moves = scratch_game.history();
      initializeArrow();
      counter = 0;
      moveThreshold = SECRETTHRESHOLD;
      makeMoveUntil();
      updateStatus();
    }; // end init()

    // Function to Flip the board
    function flipTheBoard() {
         board.orientation('flip');
    }

    // Function to pause or resume the game
    function pause() {
      if (paused) {
        paused = 0;
        $("#pauseBtn").html("Pause");
        savedCall();
        savedCall = function() {};
      }
      else
      {
        paused = 1;
        $("#pauseBtn").html("Resume");
      }
    }
  
  function progress(timer) {
      boardHeight = $('.chessboard-63f37').height();
      $('#progressBar').height(boardHeight);
      var progressBarHeight = (boardHeight / INIT_TIMER) * (INIT_TIMER - timer);
      $('#progressBar').find('div').animate({ height: progressBarHeight }, 500).html("<label style=\"text-align:center;color:red\">"+timer + " s</label>");
      
      if (progressBarHeight == (boardHeight / INIT_TIMER) * INIT_TIMER) {
          setTimeout("$('#progressBar').hide();", 1000);
      }
  }
  
  // Function to get all the legal moves
  function filterMovesForSide(moves, by) {
      var filteredMoves = [];
      for (var i = 0; i < moves.length; i++) {
          if (moves[i].color == by) {
              filteredMoves.push(moves[i]);
          }
      }
      return filteredMoves;
  }
  
  
  
  // Function to calculate unique spaces that moves can be made to
  function getMobilityForPieces(moves) {
      var mobility = [];
      var MOBILITY_THRESHOLD = 3;
      var piecesMap = {};
      
      for (var i = 0; i < moves.length; i++) {
          if(moves[i].piece != 'p') {
              var pieceDataKey = moves[i].piece + ":" + moves[i].from;
              if(pieceDataKey in piecesMap) {
                  piecesMap[pieceDataKey].push(moves[i]);
              }
              else {
                  piecesMap[pieceDataKey] = [moves[i]];
              }
          }
      }
      
      for (var key in piecesMap) {
          if (piecesMap[key].length < MOBILITY_THRESHOLD) {
              var pieceDataArr = key.split(":");
              for (var l = 0; l < piecesMap[key].length; l++) {
                  pieceMobilityData = {};
                  pieceMobilityData["move"] = piecesMap[key][l];
                  pieceMobilityData["cnt"] = piecesMap[key].length;
                  mobility.push(pieceMobilityData);
              }
          }
      }
      
      return mobility;
  }
  
  // Function to calculate unique spaces that moves can be made to
  function filterMovesOnUniqueSpaces(moves) {
      var filteredMoves = [];
      var foundSpaces = [];
      
      for (var i = 0; i < moves.length; i++) {
          if (foundSpaces.indexOf(moves[i].to) < 0) { // contains unique or not
              filteredMoves.push(moves[i]);
              foundSpaces.push(moves[i].to);
          }
      }
      
      return filteredMoves;
  }
  
  // Function to calculate spaces in opponent's camp
  function filterMovesInOpponentCamp(moves) {
      var filteredMoves = [];
      for (var i = 0; i < moves.length; i++) {
          if (parseInt(moves[i].to.charAt(1), 10) > 4) { // check if rank greater than 4 to verify if on opponent's side
              filteredMoves.push(moves[i]);
          }
      }
      return filteredMoves;
  }
  
  function initializeArrow() {
      var chessboardEl = $('.chessboard-63f37');
      chessboardEl.css('position', 'absolute');
      chessboardEl.css('z-index', 0);

      $('#arrow-svg').height(chessboardEl.height());
      $('#arrow-svg').width(chessboardEl.width());
      $('#arrow-svg').appendTo($('#board'));
      $('#arrow-svg').css('z-index', -1);

  }
  
  function updateArrow(isMoveCorrect) {
      $('#arrow-svg').css("animation", "");
      if (isMoveCorrect == 'true') {
          $('#arrow-head-path').css('fill', 'green');
          $('#arrow-path').css('stroke', 'green');
      } else {
          $('#arrow-head-path').css('fill', 'red');
          $('#arrow-path').css('stroke', 'red');
      }
      $('#arrow-path').stop();
      $('#arrow-path').css({ opacity: 1.0 });
      $('#arrow-head-path').stop();
      $('#arrow-head-path').css({ opacity: 1.0 });
      setTimeout("$('#arrow-svg').css('zIndex', -1);$('.chessboard-63f37').css('zIndex', 0);", 2000);
  }

  function drawArrow(from, to, width ) {
        fromDiv = $('*[data-square=' + from + ']');
        fromDivOffset = fromDiv.offset();
        fromX = parseInt(fromDivOffset.left + fromDiv.width() / 2);
        fromY = parseInt(fromDivOffset.top + fromDiv.height() / 2);
        
        toDiv = $('*[data-square=' + to + ']');
        toDivOffset = toDiv.offset();
        toX = parseInt(toDivOffset.left + toDiv.width() / 2);
        toY = parseInt(toDivOffset.top + toDiv.height() / 2);
        
        var arrowSvgOffset = $('#arrow-svg').offset();

        var path = document.getElementById('arrow-path');
        path.setAttribute('d', 'M'+(fromX-arrowSvgOffset.left)+','+(fromY-arrowSvgOffset.top)+' L'+(toX-arrowSvgOffset.left)+','+(toY-arrowSvgOffset.top));

        $('#arrow-svg').css("zIndex", 0);
        $('.chessboard-63f37').css("zIndex", -1);
        $('#arrow-head-path').css('fill', 'yellow');
        $('#arrow-path').css('stroke', 'yellow');
        blink($('#arrow-path'));
        blink($('#arrow-head-path'));
    }
  
    function blink(selector){
        $(selector).fadeOut('fast', function(){
                            $(this).fadeIn('fast', function(){
                                            blink(this);
                                            });
                            });
    }

    (function() {
        var nTimer = setInterval(function() {
                          if (window.jQuery) {
                             $(document).ready(init);
                             clearInterval(nTimer);
                          }
                    }, 100);
     })();
    
  </script>
</body>
</html>
